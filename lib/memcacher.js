// Generated by CoffeeScript 1.3.1
var Memcacher, async, memcached;

memcached = require('memcached');

async = require('async');

Memcacher = (function() {

  Memcacher.name = 'Memcacher';

  function Memcacher(servers) {
    if (servers == null) {
      servers = [];
    }
    this.client = new memcached(servers);
  }

  Memcacher.prototype.set = function(options, callback) {
    var tag, _i, _len, _ref;
    if (options.tags) {
      _ref = options.tags;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tag = _ref[_i];
        this.bindTagToKey({
          tag: tag,
          key: options.key
        });
      }
    }
    this.client.set(options.key, options.value, options.expireIn || options.expire_in, function() {
      if (callback) {
        return callback(false);
      }
    });
    return this;
  };

  Memcacher.prototype.get = function(options, callback) {
    var key;
    key = typeof options === 'object' ? options.key : options;
    this.client.get(key, function(err, value) {
      if (callback) {
        return callback(err, value);
      }
    });
    return this;
  };

  Memcacher.prototype.delByTag = function(options, callback) {
    var tag, that;
    tag = typeof options === 'object' ? options.tag : options;
    that = this;
    this.client.get("" + tag + "-keys", function(err, value) {
      if (!value) {
        return callback(false);
      }
      that.client.del("" + tag + "-keys", function() {});
      return async.forEach(JSON.parse(value), function(key, nextKey) {
        return that.client.del(key, function() {
          return nextKey();
        });
      }, function() {
        if (callback) {
          return callback(false);
        }
      });
    });
    return this;
  };

  Memcacher.prototype.del = function(options, callback) {
    var key, that;
    key = typeof options === 'object' ? options.key : options;
    that = this;
    this.client.get("" + key + "-tags", function(err, value) {
      if (!value) {
        return callback(false);
      }
      return async.forEach(JSON.parse(value), function(tag, nextTag) {
        return that.delByTag(tag, nextTag);
      }, function() {
        that.client.del("" + key + "-tags", function() {});
        return that.client.del(key, function() {
          if (callback) {
            return callback(false);
          }
        });
      });
    });
    return this;
  };

  Memcacher.prototype.bindTagToKey = function(options, callback) {
    var bindKeys, bindTags, that;
    that = this;
    bindKeys = function(done) {
      return that.client.get("" + options.tag + "-keys", function(err, value) {
        var keys;
        if (!value) {
          return that.client.set("" + options.tag + "-keys", JSON.stringify([options.key]), 2592000, function() {
            return done();
          });
        } else {
          keys = JSON.parse(value);
          keys.push(options.key);
          return that.client.set("" + options.tag + "-keys", JSON.stringify(keys), 2592000, function() {
            return done();
          });
        }
      });
    };
    bindTags = function(done) {
      return that.client.get("" + options.key + "-tags", function(err, value) {
        var tags;
        if (!value) {
          return that.client.set("" + options.key + "-tags", JSON.stringify([options.tag]), 2592000, function() {
            return done();
          });
        } else {
          tags = JSON.parse(value);
          tags.push(options.tag);
          return that.client.set("" + options.key + "-tags", JSON.stringify(tags), 2592000, function() {
            return done();
          });
        }
      });
    };
    return async.parallel([bindKeys, bindTags], function() {
      if (callback) {
        return callback(false);
      }
    });
  };

  Memcacher.prototype.close = function() {
    return this.client.end();
  };

  Memcacher.prototype.end = function() {
    return this.close();
  };

  return Memcacher;

})();

module.exports = Memcacher;
